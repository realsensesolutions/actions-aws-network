name: Actions AWS Network Setup
description: 'Search or Create AWS VPC and network infrastructure'

inputs:
  action:
    description: 'Action to perform: plan, apply, or destroy'
    required: false
    default: 'apply'
  force-apply:
    description: 'Force terraform apply even if resources already exist'
    required: false
    default: 'false'

outputs:
  vpc_id:
    description: "VPC ID"
    value: ${{ steps.vpc.outputs.id || steps.provision-vpc.outputs.vpc_id }}
  subnet_public_id:
    description: "First public subnet ID (backward compatibility)"
    value: ${{ steps.subnets.outputs.public_id || steps.provision-subnets.outputs.subnet_public_id }}
  subnet_private_id:
    description: "First private subnet ID (backward compatibility)"
    value: ${{ steps.subnets.outputs.private_id || steps.provision-subnets.outputs.subnet_private_id }}
  subnet_public_ids:
    description: "All public subnet IDs (comma-separated)"
    value: ${{ steps.subnets.outputs.public_ids || steps.provision-subnets.outputs.subnet_public_ids }}
  subnet_private_ids:
    description: "All private subnet IDs (comma-separated)"
    value: ${{ steps.subnets.outputs.private_ids || steps.provision-subnets.outputs.subnet_private_ids }}
  nat_gateway_id:
    description: "NAT Gateway ID"
    value: ${{ steps.nat.outputs.id || steps.provision-nat.outputs.nat_gateway_id }}
  sg_public_id:
    description: "Public Security Group ID"
    value: ${{ steps.security_groups.outputs.public_id || steps.provision-security-groups.outputs.sg_public_id }}
  sg_private_id:
    description: "Private Security Group ID"
    value: ${{ steps.security_groups.outputs.private_id || steps.provision-security-groups.outputs.sg_private_id }}

runs:
  using: "composite"
  steps:
    - name: query vpc
      shell: bash
      id: vpc
      if: ${{ inputs.action != 'destroy' }}
      env:
        SERVICE: ec2:vpc
      run: |
        arn=$(aws resourcegroupstaggingapi get-resources \
          --tag-filters Key=$TF_VAR_instance,Values=true \
          --resource-type-filters $SERVICE \
          --query "ResourceTagMappingList[].ResourceARN" \
          --output text)
        vpc_id=$(echo "$arn" | awk -F'/' '{print $2}')
        echo "TF_VAR_vpc_id=$vpc_id" >> $GITHUB_ENV
        echo "id=$vpc_id" >> $GITHUB_OUTPUT
    - name: query subnets
      shell: bash
      id: subnets
      if: ${{ inputs.action != 'destroy' }}
      env:
        SERVICE: ec2:subnet
      run: |
        arns=$(aws resourcegroupstaggingapi get-resources \
          --tag-filters Key=$TF_VAR_instance,Values=true \
          --resource-type-filters $SERVICE \
          --query "ResourceTagMappingList[].ResourceARN" \
          --output text)

        public_subnets=""
        private_subnets=""

        for arn in $arns; do
          subnet_id=$(echo "$arn" | awk -F'/' '{print $2}')
          subnet_tags=$(aws ec2 describe-subnets --subnet-ids $subnet_id --query 'Subnets[0].Tags[?Key==`Type`].Value' --output text)

          if [ "$subnet_tags" = "public" ]; then
            if [ -z "$public_subnets" ]; then
              public_subnets=$subnet_id
            else
              public_subnets="$public_subnets,$subnet_id"
            fi
          elif [ "$subnet_tags" = "private" ]; then
            if [ -z "$private_subnets" ]; then
              private_subnets=$subnet_id
            else
              private_subnets="$private_subnets,$subnet_id"
            fi
          fi
        done

        # Extract first subnet for backward compatibility
        first_public=$(echo "$public_subnets" | cut -d',' -f1)
        first_private=$(echo "$private_subnets" | cut -d',' -f1)

        # Export both singular and plural environment variables
        echo "TF_VAR_subnet_public_id=$first_public" >> $GITHUB_ENV
        echo "TF_VAR_subnet_private_id=$first_private" >> $GITHUB_ENV
        echo "TF_VAR_subnet_public_ids=$public_subnets" >> $GITHUB_ENV
        echo "TF_VAR_subnet_private_ids=$private_subnets" >> $GITHUB_ENV

        # Export both singular and plural outputs
        echo "public_id=$first_public" >> $GITHUB_OUTPUT
        echo "private_id=$first_private" >> $GITHUB_OUTPUT
        echo "public_ids=$public_subnets" >> $GITHUB_OUTPUT
        echo "private_ids=$private_subnets" >> $GITHUB_OUTPUT
    - name: query nat gateway
      shell: bash
      id: nat
      if: ${{ inputs.action != 'destroy' }}
      env:
        SERVICE: ec2:natgateway
      run: |
        arn=$(aws resourcegroupstaggingapi get-resources \
          --tag-filters Key=$TF_VAR_instance,Values=true \
          --resource-type-filters $SERVICE \
          --query "ResourceTagMappingList[].ResourceARN" \
          --output text)
        nat_id=$(echo "$arn" | awk -F'/' '{print $2}')
        echo "TF_VAR_nat_gateway_id=$nat_id" >> $GITHUB_ENV
        echo "id=$nat_id" >> $GITHUB_OUTPUT
    - name: query security groups
      shell: bash
      id: security_groups
      if: ${{ inputs.action != 'destroy' }}
      env:
        SERVICE: ec2:security-group
      run: |
        arns=$(aws resourcegroupstaggingapi get-resources \
          --tag-filters Key=$TF_VAR_instance,Values=true \
          --resource-type-filters $SERVICE \
          --query "ResourceTagMappingList[].ResourceARN" \
          --output text)

        public_sg=""
        private_sg=""

        for arn in $arns; do
          sg_id=$(echo "$arn" | awk -F'/' '{print $2}')
          sg_tags=$(aws ec2 describe-security-groups --group-ids $sg_id --query 'SecurityGroups[0].Tags[?Key==`Type`].Value' --output text)

          if [ "$sg_tags" = "public" ]; then
            public_sg=$sg_id
          elif [ "$sg_tags" = "private" ]; then
            private_sg=$sg_id
          fi
        done

        echo "TF_VAR_sg_public_id=$public_sg" >> $GITHUB_ENV
        echo "TF_VAR_sg_private_id=$private_sg" >> $GITHUB_ENV
        echo "public_id=$public_sg" >> $GITHUB_OUTPUT
        echo "private_id=$private_sg" >> $GITHUB_OUTPUT
    - name: Terraform init for apply/plan
      shell: bash
      if: ${{ inputs.action != 'destroy' }}
      working-directory: ${{ github.action_path }}
      env:
        TF_BACKEND_key: "actions-aws-network/${{ env.TF_VAR_instance }}"
      run: |
        terraform init -reconfigure \
          -backend-config="bucket=$TF_BACKEND_s3" \
          -backend-config="dynamodb_table=$TF_BACKEND_dynamodb" \
          -backend-config="key=$TF_BACKEND_key"
    - name: Terraform init for destroy
      shell: bash
      if: ${{ inputs.action == 'destroy' }}
      working-directory: ${{ github.action_path }}
      env:
        TF_BACKEND_key: "actions-aws-network/${{ env.TF_VAR_instance }}"
      run: |
        terraform init -reconfigure \
          -backend-config="bucket=$TF_BACKEND_s3" \
          -backend-config="dynamodb_table=$TF_BACKEND_dynamodb" \
          -backend-config="key=$TF_BACKEND_key"
    - name: terraform plan
      shell: bash
      if: ${{ inputs.action == 'plan' }}
      working-directory: ${{ github.action_path }}
      run: |
        terraform plan
    - name: terraform apply
      shell: bash
      if: ${{ inputs.action == 'apply' && (!steps.vpc.outputs.id || inputs.force-apply == 'true') }}
      working-directory: ${{ github.action_path }}
      run: |
        terraform apply -auto-approve
    - name: terraform destroy
      shell: bash
      if: ${{ inputs.action == 'destroy' }}
      working-directory: ${{ github.action_path }}
      run: |
        terraform destroy -auto-approve
    - name: set tf vpc
      working-directory: ${{ github.action_path }}
      shell: bash
      id: provision-vpc
      if: ${{ inputs.action == 'apply' && (!steps.vpc.outputs.id || inputs.force-apply == 'true') }}
      run: |
        VPC_ID=$(terraform output -raw vpc_id)
        echo "TF_VAR_vpc_id=$VPC_ID" >> $GITHUB_ENV
        echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
    - name: set tf subnets
      working-directory: ${{ github.action_path }}
      shell: bash
      id: provision-subnets
      if: ${{ inputs.action == 'apply' && (!steps.vpc.outputs.id || inputs.force-apply == 'true') }}
      run: |
        SUBNET_PUBLIC_ID=$(terraform output -raw subnet_public_id)
        SUBNET_PRIVATE_ID=$(terraform output -raw subnet_private_id)
        SUBNET_PUBLIC_IDS=$(terraform output -raw subnet_public_ids)
        SUBNET_PRIVATE_IDS=$(terraform output -raw subnet_private_ids)

        # Export both singular and plural environment variables
        echo "TF_VAR_subnet_public_id=$SUBNET_PUBLIC_ID" >> $GITHUB_ENV
        echo "TF_VAR_subnet_private_id=$SUBNET_PRIVATE_ID" >> $GITHUB_ENV
        echo "TF_VAR_subnet_public_ids=$SUBNET_PUBLIC_IDS" >> $GITHUB_ENV
        echo "TF_VAR_subnet_private_ids=$SUBNET_PRIVATE_IDS" >> $GITHUB_ENV

        # Export both singular and plural outputs
        echo "subnet_public_id=$SUBNET_PUBLIC_ID" >> $GITHUB_OUTPUT
        echo "subnet_private_id=$SUBNET_PRIVATE_ID" >> $GITHUB_OUTPUT
        echo "subnet_public_ids=$SUBNET_PUBLIC_IDS" >> $GITHUB_OUTPUT
        echo "subnet_private_ids=$SUBNET_PRIVATE_IDS" >> $GITHUB_OUTPUT
    - name: set tf nat gateway
      working-directory: ${{ github.action_path }}
      shell: bash
      id: provision-nat
      if: ${{ inputs.action == 'apply' && (!steps.vpc.outputs.id || inputs.force-apply == 'true') }}
      run: |
        NAT_GATEWAY_ID=$(terraform output -raw nat_gateway_id)
        echo "TF_VAR_nat_gateway_id=$NAT_GATEWAY_ID" >> $GITHUB_ENV
        echo "nat_gateway_id=$NAT_GATEWAY_ID" >> $GITHUB_OUTPUT
    - name: set tf security groups
      working-directory: ${{ github.action_path }}
      shell: bash
      id: provision-security-groups
      if: ${{ inputs.action == 'apply' && (!steps.vpc.outputs.id || inputs.force-apply == 'true') }}
      run: |
        SG_PUBLIC_ID=$(terraform output -raw sg_public_id)
        SG_PRIVATE_ID=$(terraform output -raw sg_private_id)
        echo "TF_VAR_sg_public_id=$SG_PUBLIC_ID" >> $GITHUB_ENV
        echo "TF_VAR_sg_private_id=$SG_PRIVATE_ID" >> $GITHUB_ENV
        echo "sg_public_id=$SG_PUBLIC_ID" >> $GITHUB_OUTPUT
        echo "sg_private_id=$SG_PRIVATE_ID" >> $GITHUB_OUTPUT

